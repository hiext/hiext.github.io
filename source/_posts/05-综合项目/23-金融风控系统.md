# ç¬¬23ç« ï¼šæ™ºèƒ½é‡‘èé£æ§ç³»ç»Ÿ

## ğŸ“ é¡¹ç›®æ¦‚è¿°

å¼€å‘ä¸€ä¸ªå®Œæ•´çš„é‡‘èé£æ§ç³»ç»Ÿï¼ŒåŒ…å«ä¿¡ç”¨è¯„åˆ†ã€æ¬ºè¯ˆæ£€æµ‹ã€é£é™©é¢„è­¦ç­‰åŠŸèƒ½ã€‚

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- ğŸ’³ ä¿¡ç”¨è¯„åˆ†æ¨¡å‹
- ğŸ” æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ
- âš ï¸ é£é™©é¢„è­¦æœºåˆ¶
- ğŸ“Š å¯è§£é‡ŠAI(XAI)

## 23.1 ä¿¡ç”¨è¯„åˆ†æ¨¡å‹

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.model_selection import train_test_split

class CreditScoringModel:
    """ä¿¡ç”¨è¯„åˆ†æ¨¡å‹"""
    
    def __init__(self):
        self.model = GradientBoostingClassifier(
            n_estimators=100,
            learning_rate=0.1,
            max_depth=5
        )
        self.feature_names = []
    
    def prepare_features(self, df):
        """ç‰¹å¾å·¥ç¨‹"""
        features = pd.DataFrame()
        
        # åŸºç¡€ç‰¹å¾
        features['age'] = df['age']
        features['income'] = df['income']
        features['loan_amount'] = df['loan_amount']
        
        # è¡ç”Ÿç‰¹å¾
        features['loan_to_income'] = df['loan_amount'] / (df['income'] + 1)
        features['employment_length'] = df['employment_length']
        
        # å†å²ç‰¹å¾
        features['credit_history_length'] = df['credit_history_length']
        features['num_credit_lines'] = df['num_credit_lines']
        features['delinquency_count'] = df['delinquency_count']
        
        self.feature_names = features.columns.tolist()
        return features
    
    def train(self, X, y):
        """è®­ç»ƒæ¨¡å‹"""
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )
        
        self.model.fit(X_train, y_train)
        
        # è¯„ä¼°
        train_score = self.model.score(X_train, y_train)
        test_score = self.model.score(X_test, y_test)
        
        print(f"è®­ç»ƒé›†å‡†ç¡®ç‡: {train_score:.4f}")
        print(f"æµ‹è¯•é›†å‡†ç¡®ç‡: {test_score:.4f}")
    
    def predict_score(self, features):
        """é¢„æµ‹ä¿¡ç”¨åˆ†æ•°"""
        probability = self.model.predict_proba(features)[:, 1]
        score = (probability * 850 + 300).astype(int)
        return score
    
    def get_risk_level(self, score):
        """é£é™©ç­‰çº§"""
        if score >= 750:
            return "ä¼˜ç§€"
        elif score >= 700:
            return "è‰¯å¥½"
        elif score >= 650:
            return "ä¸­ç­‰"
        else:
            return "è¾ƒå·®"
```

## 23.2 æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ

```python
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler

class FraudDetectionSystem:
    """æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ"""
    
    def __init__(self):
        self.scaler = StandardScaler()
        self.model = IsolationForest(
            contamination=0.01,
            random_state=42
        )
    
    def extract_features(self, transaction):
        """æå–äº¤æ˜“ç‰¹å¾"""
        features = {
            'amount': transaction['amount'],
            'hour': transaction['timestamp'].hour,
            'day_of_week': transaction['timestamp'].dayofweek,
            'location_distance': self._calculate_distance(transaction),
            'frequency_1h': self._get_frequency(transaction, hours=1),
            'frequency_24h': self._get_frequency(transaction, hours=24)
        }
        return pd.DataFrame([features])
    
    def _calculate_distance(self, transaction):
        """è®¡ç®—åœ°ç†è·ç¦»"""
        # ç®€åŒ–ç¤ºä¾‹
        return np.random.rand() * 1000
    
    def _get_frequency(self, transaction, hours):
        """è·å–äº¤æ˜“é¢‘ç‡"""
        # ç®€åŒ–ç¤ºä¾‹
        return np.random.randint(0, 10)
    
    def detect(self, transaction):
        """æ£€æµ‹æ¬ºè¯ˆ"""
        features = self.extract_features(transaction)
        features_scaled = self.scaler.transform(features)
        
        prediction = self.model.predict(features_scaled)
        score = self.model.score_samples(features_scaled)
        
        is_fraud = prediction[0] == -1
        risk_score = 1 / (1 + np.exp(score[0]))  # è½¬æ¢ä¸ºæ¦‚ç‡
        
        return {
            'is_fraud': is_fraud,
            'risk_score': risk_score,
            'risk_level': 'high' if risk_score > 0.8 else 'medium' if risk_score > 0.5 else 'low'
        }
```

## 23.3 å®Œæ•´é£æ§ç³»ç»Ÿ

```python
class RiskControlSystem:
    """å®Œæ•´é£æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.credit_model = CreditScoringModel()
        self.fraud_detector = FraudDetectionSystem()
        self.alert_threshold = 0.8
    
    def evaluate_loan_application(self, application_data):
        """è¯„ä¼°è´·æ¬¾ç”³è¯·"""
        # ä¿¡ç”¨è¯„åˆ†
        features = self.credit_model.prepare_features(
            pd.DataFrame([application_data])
        )
        credit_score = self.credit_model.predict_score(features)[0]
        risk_level = self.credit_model.get_risk_level(credit_score)
        
        # å†³ç­–
        decision = self._make_decision(credit_score, application_data)
        
        return {
            'credit_score': int(credit_score),
            'risk_level': risk_level,
            'decision': decision,
            'approved': decision == 'approved',
            'reason': self._get_reason(credit_score, risk_level)
        }
    
    def _make_decision(self, score, data):
        """è´·æ¬¾å†³ç­–"""
        if score >= 700:
            return 'approved'
        elif score >= 650:
            return 'manual_review'
        else:
            return 'rejected'
    
    def _get_reason(self, score, risk_level):
        """å†³ç­–åŸå› """
        if score >= 700:
            return "ä¿¡ç”¨è‰¯å¥½ï¼Œè‡ªåŠ¨æ‰¹å‡†"
        elif score >= 650:
            return "éœ€äººå·¥å®¡æ ¸"
        else:
            return "ä¿¡ç”¨åˆ†æ•°è¿‡ä½"
    
    def monitor_transaction(self, transaction):
        """ç›‘æ§äº¤æ˜“"""
        fraud_result = self.fraud_detector.detect(transaction)
        
        if fraud_result['is_fraud']:
            self._trigger_alert(transaction, fraud_result)
        
        return fraud_result
    
    def _trigger_alert(self, transaction, fraud_result):
        """è§¦å‘è­¦æŠ¥"""
        print(f"""
        âš ï¸  æ¬ºè¯ˆè­¦æŠ¥
        äº¤æ˜“ID: {transaction.get('id', 'N/A')}
        é‡‘é¢: {transaction.get('amount', 0)}
        é£é™©åˆ†æ•°: {fraud_result['risk_score']:.2f}
        """)

# ä½¿ç”¨ç¤ºä¾‹
system = RiskControlSystem()

# è¯„ä¼°è´·æ¬¾ç”³è¯·
application = {
    'age': 35,
    'income': 80000,
    'loan_amount': 200000,
    'employment_length': 5,
    'credit_history_length': 10,
    'num_credit_lines': 3,
    'delinquency_count': 0
}

result = system.evaluate_loan_application(application)
print(f"ä¿¡ç”¨åˆ†æ•°: {result['credit_score']}")
print(f"å†³ç­–: {result['decision']}")
```

## 23.4 å¯è§£é‡ŠAI

```python
import shap

class ExplainableAI:
    """å¯è§£é‡ŠAI"""
    
    def __init__(self, model):
        self.model = model
        self.explainer = shap.TreeExplainer(model)
    
    def explain_prediction(self, features):
        """è§£é‡Šé¢„æµ‹ç»“æœ"""
        shap_values = self.explainer.shap_values(features)
        
        # ç‰¹å¾é‡è¦æ€§
        importance = pd.DataFrame({
            'feature': features.columns,
            'impact': np.abs(shap_values[0]).mean(axis=0)
        }).sort_values('impact', ascending=False)
        
        return importance
```

## ğŸ“š æœ¬ç« å°ç»“
- âœ… ä¿¡ç”¨è¯„åˆ†æ¨¡å‹
- âœ… æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ
- âœ… é£é™©é¢„è­¦æœºåˆ¶
- âœ… å®Œæ•´é£æ§æµç¨‹
- âœ… å¯è§£é‡ŠAIåº”ç”¨

[â¬…ï¸ ä¸Šä¸€ç« ](./22-åŒ»ç–—è¯Šæ–­åŠ©æ‰‹.md) | [è¿”å›ç›®å½•](../README.md) | [ä¸‹ä¸€ç«  â¡ï¸](./24-æ™ºèƒ½æ•™è‚²å¹³å°.md)
