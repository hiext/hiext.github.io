# 第22章：AI医疗诊断助手

## 📝 项目概述

开发一个智能医疗诊断辅助系统，整合图像识别、自然语言处理和知识图谱技术，为医生提供诊断建议。

**核心功能**：
- 🔬 医学影像分析（X光、CT、MRI）
- 📋 病历文本理解与信息抽取
- 🧠 基于知识图谱的诊断推理
- 💊 用药建议与风险预警
- 📊 可视化诊断报告生成

**技术栈**：
- 深度学习：PyTorch、TensorFlow
- 图像处理：OpenCV、Pillow
- NLP：Transformers、spaCy
- 知识图谱：Neo4j
- Web框架：FastAPI、React

---

## 22.1 系统架构设计

### 整体架构

```
┌─────────────────────────────────────────────────┐
│                 Web前端界面                      │
│         (React + Ant Design)                   │
└──────────────────┬──────────────────────────────┘
                   │ REST API
┌──────────────────┴──────────────────────────────┐
│              后端服务层 (FastAPI)                │
├─────────────────────────────────────────────────┤
│  医学影像模块  │  文本分析模块  │  推理引擎模块 │
└─────────┬────────────┬────────────┬─────────────┘
          │            │            │
┌─────────┴────┐  ┌───┴─────┐  ┌──┴──────────┐
│ 影像识别模型  │  │ NLP模型  │  │ 知识图谱     │
│ (ResNet/YOLO)│  │ (BERT)   │  │ (Neo4j)     │
└──────────────┘  └──────────┘  └─────────────┘
```

---

## 22.2 医学影像分析模块

### 22.2.1 肺部X光片分析

```python
# 肺部疾病检测系统
import torch
import torch.nn as nn
import torchvision.models as models
import torchvision.transforms as transforms
from PIL import Image
import numpy as np
import cv2

class ChestXrayClassifier:
    """胸部X光片疾病分类器"""
    
    def __init__(self, model_path=None, device='cuda'):
        self.device = torch.device(device if torch.cuda.is_available() else 'cpu')
        self.model = self._build_model()
        
        if model_path:
            self.load_model(model_path)
        
        self.classes = [
            '正常', '肺炎', '肺结核', '肺癌', 
            '气胸', '胸腔积液', '心脏肥大'
        ]
        
        self.transform = transforms.Compose([
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(
                mean=[0.485, 0.456, 0.406],
                std=[0.229, 0.224, 0.225]
            )
        ])
    
    def _build_model(self):
        """构建模型"""
        # 使用预训练的DenseNet
        model = models.densenet121(pretrained=True)
        
        # 修改最后一层
        num_features = model.classifier.in_features
        model.classifier = nn.Sequential(
            nn.Linear(num_features, 512),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(512, 7)  # 7种疾病分类
        )
        
        return model.to(self.device)
    
    def predict(self, image_path, grad_cam=True):
        """
        预测X光片
        
        Args:
            image_path: 图像路径
            grad_cam: 是否生成热力图
            
        Returns:
            预测结果和可视化
        """
        # 加载图像
        image = Image.open(image_path).convert('RGB')
        image_tensor = self.transform(image).unsqueeze(0).to(self.device)
        
        # 预测
        self.model.eval()
        with torch.no_grad():
            outputs = self.model(image_tensor)
            probabilities = torch.softmax(outputs, dim=1)[0]
        
        # 获取预测结果
        predictions = []
        for idx, prob in enumerate(probabilities):
            predictions.append({
                'disease': self.classes[idx],
                'probability': float(prob),
                'confidence': 'high' if prob > 0.7 else 'medium' if prob > 0.4 else 'low'
            })
        
        predictions.sort(key=lambda x: x['probability'], reverse=True)
        
        # 生成Grad-CAM热力图
        heatmap = None
        if grad_cam:
            heatmap = self._generate_gradcam(image_path, image_tensor)
        
        return {
            'predictions': predictions,
            'heatmap': heatmap,
            'primary_diagnosis': predictions[0]['disease'],
            'confidence': predictions[0]['confidence']
        }
    
    def _generate_gradcam(self, original_image_path, image_tensor):
        """生成Grad-CAM热力图"""
        # 简化版Grad-CAM实现
        self.model.eval()
        
        # 前向传播
        features = []
        gradients = []
        
        def forward_hook(module, input, output):
            features.append(output)
        
        def backward_hook(module, grad_input, grad_output):
            gradients.append(grad_output[0])
        
        # 注册hook
        target_layer = self.model.features[-1]
        forward_handle = target_layer.register_forward_hook(forward_hook)
        backward_handle = target_layer.register_backward_hook(backward_hook)
        
        # 前向传播
        output = self.model(image_tensor)
        
        # 反向传播
        self.model.zero_grad()
        target = output.argmax()
        output[0, target].backward()
        
        # 计算权重
        pooled_gradients = torch.mean(gradients[0], dim=[0, 2, 3])
        
        # 加权特征图
        for i in range(features[0].shape[1]):
            features[0][:, i, :, :] *= pooled_gradients[i]
        
        # 生成热力图
        heatmap = torch.mean(features[0], dim=1).squeeze()
        heatmap = np.maximum(heatmap.cpu().detach().numpy(), 0)
        heatmap = heatmap / heatmap.max()
        
        # 移除hook
        forward_handle.remove()
        backward_handle.remove()
        
        # 叠加到原图
        original_image = cv2.imread(original_image_path)
        original_image = cv2.resize(original_image, (224, 224))
        
        heatmap_resized = cv2.resize(heatmap, (224, 224))
        heatmap_colored = cv2.applyColorMap(
            np.uint8(255 * heatmap_resized), 
            cv2.COLORMAP_JET
        )
        
        superimposed = cv2.addWeighted(
            original_image, 0.6, 
            heatmap_colored, 0.4, 
            0
        )
        
        return superimposed
    
    def batch_predict(self, image_paths):
        """批量预测"""
        results = []
        for path in image_paths:
            result = self.predict(path, grad_cam=False)
            results.append(result)
        return results
    
    def save_model(self, path):
        """保存模型"""
        torch.save({
            'model_state_dict': self.model.state_dict(),
            'classes': self.classes
        }, path)
        print(f"✅ 模型已保存: {path}")
    
    def load_model(self, path):
        """加载模型"""
        checkpoint = torch.load(path, map_location=self.device)
        self.model.load_state_dict(checkpoint['model_state_dict'])
        self.classes = checkpoint['classes']
        print(f"✅ 模型已加载: {path}")


# ========== 使用示例 ==========

# 初始化分类器
classifier = ChestXrayClassifier(device='cpu')

# 预测单张X光片
result = classifier.predict('chest_xray.jpg')

print("🔬 诊断结果:")
print(f"主要诊断: {result['primary_diagnosis']}")
print(f"置信度: {result['confidence']}")
print("\n详细预测:")
for pred in result['predictions'][:3]:
    print(f"  {pred['disease']}: {pred['probability']*100:.2f}%")
```

---

## 22.3 病历文本分析模块

### 22.3.1 命名实体识别

```python
# 医疗文本NER系统
from transformers import (
    AutoTokenizer, 
    AutoModelForTokenClassification,
    pipeline
)
import re

class MedicalNER:
    """医疗命名实体识别"""
    
    def __init__(self, model_name='bert-base-chinese'):
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModelForTokenClassification.from_pretrained(
            model_name,
            num_labels=9  # 实体类型数量
        )
        
        self.entity_labels = [
            'O',           # 非实体
            'B-DISEASE',   # 疾病-开始
            'I-DISEASE',   # 疾病-内部
            'B-SYMPTOM',   # 症状-开始
            'I-SYMPTOM',   # 症状-内部
            'B-DRUG',      # 药物-开始
            'I-DRUG',      # 药物-内部
            'B-TEST',      # 检查-开始
            'I-TEST'       # 检查-内部
        ]
        
        self.ner_pipeline = pipeline(
            'ner',
            model=self.model,
            tokenizer=self.tokenizer
        )
    
    def extract_entities(self, text):
        """
        提取医疗实体
        
        Args:
            text: 病历文本
            
        Returns:
            提取的实体字典
        """
        # NER预测
        ner_results = self.ner_pipeline(text)
        
        # 整合实体
        entities = {
            'diseases': [],
            'symptoms': [],
            'drugs': [],
            'tests': []
        }
        
        current_entity = None
        current_type = None
        
        for result in ner_results:
            label = result['entity']
            word = result['word']
            
            if label.startswith('B-'):
                # 新实体开始
                if current_entity:
                    self._add_entity(entities, current_type, current_entity)
                
                current_type = label[2:]
                current_entity = word
            
            elif label.startswith('I-') and current_entity:
                # 实体继续
                current_entity += word
        
        # 添加最后一个实体
        if current_entity:
            self._add_entity(entities, current_type, current_entity)
        
        return entities
    
    def _add_entity(self, entities_dict, entity_type, entity_text):
        """添加实体到字典"""
        type_map = {
            'DISEASE': 'diseases',
            'SYMPTOM': 'symptoms',
            'DRUG': 'drugs',
            'TEST': 'tests'
        }
        
        key = type_map.get(entity_type)
        if key and entity_text not in entities_dict[key]:
            entities_dict[key].append(entity_text)
    
    def analyze_medical_record(self, record_text):
        """
        分析完整病历
        
        Args:
            record_text: 病历文本
            
        Returns:
            结构化病历信息
        """
        # 提取实体
        entities = self.extract_entities(record_text)
        
        # 提取其他信息
        analysis = {
            'entities': entities,
            'patient_info': self._extract_patient_info(record_text),
            'chief_complaint': self._extract_chief_complaint(record_text),
            'history': self._extract_history(record_text)
        }
        
        return analysis
    
    def _extract_patient_info(self, text):
        """提取患者信息"""
        info = {}
        
        # 年龄
        age_match = re.search(r'(\d+)岁', text)
        if age_match:
            info['age'] = int(age_match.group(1))
        
        # 性别
        if '男' in text[:50]:
            info['gender'] = '男'
        elif '女' in text[:50]:
            info['gender'] = '女'
        
        return info
    
    def _extract_chief_complaint(self, text):
        """提取主诉"""
        patterns = [
            r'主诉[：:](.*?)(?:现病史|既往史|$)',
            r'主要症状[：:](.*?)(?:\n|$)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                return match.group(1).strip()
        
        return ""
    
    def _extract_history(self, text):
        """提取病史"""
        history = {}
        
        # 现病史
        present_match = re.search(
            r'现病史[：:](.*?)(?:既往史|个人史|$)', 
            text, 
            re.DOTALL
        )
        if present_match:
            history['present_illness'] = present_match.group(1).strip()
        
        # 既往史
        past_match = re.search(
            r'既往史[：:](.*?)(?:个人史|家族史|$)', 
            text, 
            re.DOTALL
        )
        if past_match:
            history['past_illness'] = past_match.group(1).strip()
        
        return history


# ========== 使用示例 ==========

# 示例病历
medical_record = """
患者张三，男，45岁。
主诉：反复咳嗽、咳痰伴发热3天。
现病史：患者3天前无明显诱因出现咳嗽、咳痰，痰色黄，伴发热，
体温最高39.2℃，伴畏寒、乏力。
既往史：有高血压病史5年，规律服用硝苯地平缓释片。
体格检查：体温38.5℃，双肺呼吸音粗，可闻及湿啰音。
辅助检查：血常规示白细胞12.5×10^9/L，中性粒细胞85%。
胸部X线片示右下肺炎性改变。
"""

# 分析病历
ner = MedicalNER()
analysis = ner.analyze_medical_record(medical_record)

print("📋 病历分析结果:")
print(f"\n患者信息: {analysis['patient_info']}")
print(f"\n主诉: {analysis['chief_complaint']}")
print(f"\n提取的实体:")
for entity_type, entities in analysis['entities'].items():
    if entities:
        print(f"  {entity_type}: {', '.join(entities)}")
```

---

## 22.4 诊断推理引擎

### 22.4.1 基于规则的推理

```python
# 诊断推理系统
from typing import List, Dict
import json

class DiagnosisReasoner:
    """诊断推理引擎"""
    
    def __init__(self, knowledge_base_path='medical_kb.json'):
        self.knowledge_base = self._load_knowledge_base(knowledge_base_path)
        self.diagnosis_history = []
    
    def _load_knowledge_base(self, path):
        """加载医学知识库"""
        # 简化的知识库结构
        kb = {
            '肺炎': {
                'symptoms': ['咳嗽', '咳痰', '发热', '胸痛'],
                'tests': ['血常规异常', 'X线肺部阴影'],
                'risk_factors': ['吸烟', '免疫力低下'],
                'severity_indicators': ['高热', '呼吸困难', '意识障碍'],
                'treatment': ['抗生素', '止咳化痰', '退热']
            },
            '肺结核': {
                'symptoms': ['咳嗽', '咳痰', '低热', '盗汗', '消瘦'],
                'tests': ['痰涂片阳性', 'X线肺部空洞'],
                'risk_factors': ['接触史', '免疫力低下'],
                'severity_indicators': ['咯血', '呼吸衰竭'],
                'treatment': ['抗结核药物', '营养支持']
            },
            '心力衰竭': {
                'symptoms': ['呼吸困难', '水肿', '乏力'],
                'tests': ['心脏超声异常', 'BNP升高'],
                'risk_factors': ['高血压', '冠心病', '心肌病'],
                'severity_indicators': ['端坐呼吸', '少尿'],
                'treatment': ['利尿剂', '强心药']
            }
        }
        
        return kb
    
    def reason(self, symptoms: List[str], test_results: List[str], 
               patient_history: Dict = None):
        """
        诊断推理
        
        Args:
            symptoms: 症状列表
            test_results: 检查结果列表
            patient_history: 患者病史
            
        Returns:
            诊断建议
        """
        diagnoses = []
        
        # 遍历知识库中的疾病
        for disease, disease_info in self.knowledge_base.items():
            score = self._calculate_disease_score(
                disease_info,
                symptoms,
                test_results,
                patient_history
            )
            
            if score > 0:
                # 评估严重程度
                severity = self._assess_severity(
                    disease_info,
                    symptoms,
                    test_results
                )
                
                diagnoses.append({
                    'disease': disease,
                    'confidence': min(score / 10, 1.0),
                    'severity': severity,
                    'matched_symptoms': self._get_matched_items(
                        symptoms, 
                        disease_info['symptoms']
                    ),
                    'matched_tests': self._get_matched_items(
                        test_results,
                        disease_info['tests']
                    ),
                    'treatment_suggestions': disease_info['treatment']
                })
        
        # 排序
        diagnoses.sort(key=lambda x: x['confidence'], reverse=True)
        
        # 生成诊断报告
        report = self._generate_report(diagnoses, symptoms, test_results)
        
        return {
            'diagnoses': diagnoses,
            'report': report
        }
    
    def _calculate_disease_score(self, disease_info, symptoms, 
                                  test_results, patient_history):
        """计算疾病评分"""
        score = 0
        
        # 症状匹配
        for symptom in symptoms:
            if symptom in disease_info['symptoms']:
                score += 3
        
        # 检查结果匹配
        for test in test_results:
            if any(test in t for t in disease_info['tests']):
                score += 5
        
        # 风险因素
        if patient_history:
            for risk in disease_info.get('risk_factors', []):
                if risk in str(patient_history):
                    score += 2
        
        return score
    
    def _assess_severity(self, disease_info, symptoms, test_results):
        """评估疾病严重程度"""
        severity_score = 0
        
        for indicator in disease_info.get('severity_indicators', []):
            if indicator in symptoms or indicator in str(test_results):
                severity_score += 1
        
        if severity_score >= 2:
            return 'severe'
        elif severity_score == 1:
            return 'moderate'
        else:
            return 'mild'
    
    def _get_matched_items(self, input_list, reference_list):
        """获取匹配项"""
        matched = []
        for item in input_list:
            if item in reference_list:
                matched.append(item)
        return matched
    
    def _generate_report(self, diagnoses, symptoms, test_results):
        """生成诊断报告"""
        report = {
            'summary': '',
            'primary_diagnosis': None,
            'differential_diagnoses': [],
            'recommendations': []
        }
        
        if diagnoses:
            primary = diagnoses[0]
            report['primary_diagnosis'] = primary['disease']
            
            # 摘要
            report['summary'] = f"""
基于患者症状（{', '.join(symptoms)}）和检查结果（{', '.join(test_results)}），
初步诊断为{primary['disease']}，置信度{primary['confidence']*100:.1f}%，
疾病严重程度评估为{primary['severity']}。
            """.strip()
            
            # 鉴别诊断
            if len(diagnoses) > 1:
                report['differential_diagnoses'] = [
                    d['disease'] for d in diagnoses[1:3]
                ]
            
            # 建议
            report['recommendations'] = [
                f"建议治疗方案：{', '.join(primary['treatment_suggestions'])}",
                "建议进一步完善相关检查",
                "密切观察病情变化"
            ]
            
            if primary['severity'] == 'severe':
                report['recommendations'].insert(0, "⚠️ 病情较重，建议立即住院治疗")
        
        return report


# ========== 使用示例 ==========

reasoner = DiagnosisReasoner()

# 输入症状和检查结果
symptoms = ['咳嗽', '咳痰', '发热', '胸痛']
test_results = ['血常规异常', 'X线肺部阴影']
history = {'past_illness': '吸烟史20年'}

# 推理诊断
result = reasoner.reason(symptoms, test_results, history)

print("🧠 诊断推理结果:")
print(f"\n{result['report']['summary']}")
print(f"\n主要诊断: {result['report']['primary_diagnosis']}")

if result['report']['differential_diagnoses']:
    print(f"鉴别诊断: {', '.join(result['report']['differential_diagnoses'])}")

print("\n💊 治疗建议:")
for rec in result['report']['recommendations']:
    print(f"  • {rec}")

print("\n详细诊断列表:")
for diag in result['diagnoses']:
    print(f"\n  {diag['disease']} (置信度: {diag['confidence']*100:.1f}%)")
    print(f"    匹配症状: {', '.join(diag['matched_symptoms'])}")
    print(f"    严重程度: {diag['severity']}")
```

---

## 22.5 完整系统集成

```python
# 完整的AI医疗诊断助手
from datetime import datetime
import uuid

class MedicalDiagnosisAssistant:
    """AI医疗诊断助手 - 完整系统"""
    
    def __init__(self):
        self.xray_classifier = ChestXrayClassifier()
        self.ner = MedicalNER()
        self.reasoner = DiagnosisReasoner()
        
        self.session_id = str(uuid.uuid4())
        self.diagnosis_history = []
    
    def diagnose(self, patient_data):
        """
        完整诊断流程
        
        Args:
            patient_data: {
                'medical_record': 病历文本,
                'xray_image': X光片路径(可选),
                'patient_info': 患者基本信息
            }
        """
        diagnosis_result = {
            'session_id': self.session_id,
            'timestamp': datetime.now().isoformat(),
            'patient_info': patient_data.get('patient_info', {}),
            'image_analysis': None,
            'text_analysis': None,
            'final_diagnosis': None
        }
        
        # 1. 影像分析
        if 'xray_image' in patient_data:
            print("🔬 正在分析医学影像...")
            image_result = self.xray_classifier.predict(
                patient_data['xray_image']
            )
            diagnosis_result['image_analysis'] = image_result
        
        # 2. 病历文本分析
        if 'medical_record' in patient_data:
            print("📋 正在分析病历文本...")
            text_result = self.ner.analyze_medical_record(
                patient_data['medical_record']
            )
            diagnosis_result['text_analysis'] = text_result
        
        # 3. 综合推理
        print("🧠 正在进行诊断推理...")
        symptoms = []
        test_results = []
        
        # 从文本分析获取症状
        if diagnosis_result['text_analysis']:
            symptoms = diagnosis_result['text_analysis']['entities'].get('symptoms', [])
            test_results = diagnosis_result['text_analysis']['entities'].get('tests', [])
        
        # 从影像分析获取诊断
        if diagnosis_result['image_analysis']:
            primary_image_diagnosis = diagnosis_result['image_analysis']['primary_diagnosis']
            if primary_image_diagnosis != '正常':
                test_results.append(f'X光显示{primary_image_diagnosis}')
        
        # 推理
        reasoning_result = self.reasoner.reason(
            symptoms=symptoms,
            test_results=test_results,
            patient_history=diagnosis_result.get('text_analysis', {}).get('history')
        )
        
        diagnosis_result['final_diagnosis'] = reasoning_result
        
        # 4. 生成综合报告
        diagnosis_result['comprehensive_report'] = self._generate_comprehensive_report(
            diagnosis_result
        )
        
        # 保存历史
        self.diagnosis_history.append(diagnosis_result)
        
        return diagnosis_result
    
    def _generate_comprehensive_report(self, diagnosis_result):
        """生成综合诊断报告"""
        report = {
            'title': '医疗诊断辅助报告',
            'timestamp': diagnosis_result['timestamp'],
            'sections': []
        }
        
        # 患者信息
        if diagnosis_result.get('patient_info'):
            report['sections'].append({
                'title': '患者信息',
                'content': diagnosis_result['patient_info']
            })
        
        # 影像分析
        if diagnosis_result.get('image_analysis'):
            ia = diagnosis_result['image_analysis']
            report['sections'].append({
                'title': '影像学分析',
                'content': f"主要发现: {ia['primary_diagnosis']} (置信度: {ia['confidence']})"
            })
        
        # 临床表现
        if diagnosis_result.get('text_analysis'):
            ta = diagnosis_result['text_analysis']
            report['sections'].append({
                'title': '临床表现',
                'content': {
                    '主诉': ta.get('chief_complaint'),
                    '症状': ta['entities'].get('symptoms', []),
                    '检查': ta['entities'].get('tests', [])
                }
            })
        
        # 诊断结论
        if diagnosis_result.get('final_diagnosis'):
            fd = diagnosis_result['final_diagnosis']
            report['sections'].append({
                'title': '诊断结论',
                'content': fd['report']
            })
        
        return report
    
    def print_report(self, diagnosis_result):
        """打印诊断报告"""
        report = diagnosis_result['comprehensive_report']
        
        print("\n" + "="*60)
        print(f"  {report['title']}")
        print("="*60)
        print(f"生成时间: {report['timestamp']}\n")
        
        for section in report['sections']:
            print(f"\n【{section['title']}】")
            print("-" * 60)
            
            content = section['content']
            if isinstance(content, dict):
                for key, value in content.items():
                    print(f"{key}: {value}")
            else:
                print(content)
        
        print("\n" + "="*60)


# ========== 完整使用示例 ==========

if __name__ == "__main__":
    # 初始化系统
    assistant = MedicalDiagnosisAssistant()
    
    # 准备患者数据
    patient_data = {
        'patient_info': {
            'name': '张三',
            'age': 45,
            'gender': '男'
        },
        'medical_record': medical_record,  # 前面定义的病历
        # 'xray_image': 'chest_xray.jpg'  # 可选
    }
    
    # 执行诊断
    print("🏥 AI医疗诊断助手")
    print("="*60)
    
    result = assistant.diagnose(patient_data)
    
    # 打印报告
    assistant.print_report(result)
    
    print("\n✅ 诊断完成！")
    print("\n⚠️  注意：本系统仅供辅助参考，最终诊断需由专业医生确认。")
```

---

## 📚 本章小结

- ✅ 开发了医学影像分析模块（X光片分类）
- ✅ 实现了病历文本NER和信息抽取
- ✅ 构建了基于规则的诊断推理引擎
- ✅ 集成了完整的AI医疗诊断助手系统
- ✅ 生成了结构化的诊断报告

**项目亮点**：
- 多模态数据融合（图像+文本）
- Grad-CAM可解释性
- 知识驱动的推理
- 完整的临床应用流程

---

## 🎯 扩展方向

1. **功能扩展**：
   - 支持更多医学影像类型（CT、MRI）
   - 集成知识图谱进行深度推理
   - 添加用药建议和相互作用检查

2. **性能优化**：
   - 模型蒸馏提升推理速度
   - 边缘部署支持离线使用
   - 联邦学习保护隐私

3. **工程化**：
   - Docker容器化部署
   - RESTful API接口
   - Web前端界面开发
   - 与医院HIS系统对接

---

[⬅️ 上一章](./21-语音技术应用.md) | [返回目录](../README.md) | [下一章 ➡️](./23-金融风控系统.md)
