# 第16章：智能推荐系统

## 📝 本章目标

- 理解推荐系统的核心原理和分类
- 掌握协同过滤算法的实现
- 学习深度学习推荐模型
- 解决冷启动等实际问题
- 开发完整的电商推荐系统

---

## 16.1 推荐系统概述

### 应用场景
- 📦 电商：商品推荐
- 🎬 视频：内容推荐  
- 🎵 音乐：歌曲推荐
- 📰 新闻：文章推荐

### 推荐算法分类
```
1. 协同过滤（CF）
   - 用户协同过滤
   - 物品协同过滤
   - 矩阵分解

2. 深度学习推荐
   - Neural CF
   - Wide & Deep
   - DeepFM

3. 混合推荐
   - 多策略融合
```

---

## 16.2 完整案例：电商推荐系统

### 系统架构

```python
# 电商推荐系统完整实现
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime
import joblib

class EcommerceRecommender:
    """电商推荐系统 - 生产级实现"""
    
    def __init__(self, config=None):
        self.config = config or {
            'cf_k': 20,
            'recall_size': 100,
            'rank_size': 20,
            'diversity_weight': 0.3
        }
        
        # 模型组件
        self.user_item_matrix = None
        self.item_similarity = None
        
        # 数据存储
        self.user_profiles = {}
        self.item_features = {}
        self.hot_items = []
        
    # ========== 数据处理 ==========
    
    def prepare_data(self, interactions_df, items_df):
        """
        准备训练数据
        
        Args:
            interactions_df: 用户行为数据 [user_id, item_id, rating, timestamp]
            items_df: 商品信息 [item_id, category, price, brand, etc]
        """
        print("📊 开始数据准备...")
        
        # 1. 构建用户-物品矩阵
        self.user_item_matrix = interactions_df.pivot_table(
            index='user_id',
            columns='item_id', 
            values='rating',
            fill_value=0
        )
        print(f"✅ 用户-物品矩阵: {self.user_item_matrix.shape}")
        
        # 2. 计算物品相似度
        self.item_similarity = pd.DataFrame(
            cosine_similarity(self.user_item_matrix.T),
            index=self.user_item_matrix.columns,
            columns=self.user_item_matrix.columns
        )
        print(f"✅ 物品相似度矩阵: {self.item_similarity.shape}")
        
        # 3. 提取热门商品
        item_popularity = interactions_df['item_id'].value_counts()
        self.hot_items = item_popularity.head(50).index.tolist()
        print(f"✅ 热门商品数: {len(self.hot_items)}")
        
        # 4. 构建商品特征
        for _, row in items_df.iterrows():
            self.item_features[row['item_id']] = {
                'category': row.get('category', 'unknown'),
                'price': row.get('price', 0),
                'brand': row.get('brand', 'unknown'),
                'rating': row.get('rating', 0)
            }
        print(f"✅ 商品特征数: {len(self.item_features)}")
        
        # 5. 构建用户画像
        self._build_user_profiles(interactions_df)
        
        print("✅ 数据准备完成！\n")
    
    def _build_user_profiles(self, interactions_df):
        """构建用户画像"""
        for user_id in interactions_df['user_id'].unique():
            user_data = interactions_df[interactions_df['user_id'] == user_id]
            
            # 用户购买的商品
            user_items = user_data['item_id'].tolist()
            
            # 偏好类目
            categories = []
            prices = []
            brands = []
            
            for item_id in user_items:
                if item_id in self.item_features:
                    feature = self.item_features[item_id]
                    categories.append(feature['category'])
                    prices.append(feature['price'])
                    brands.append(feature['brand'])
            
            self.user_profiles[user_id] = {
                'favorite_categories': pd.Series(categories).value_counts().head(3).index.tolist() if categories else [],
                'favorite_brands': pd.Series(brands).value_counts().head(3).index.tolist() if brands else [],
                'avg_price': np.mean(prices) if prices else 0,
                'purchase_count': len(user_items)
            }
    
    # ========== 召回阶段 ==========
    
    def recall_candidates(self, user_id, exclude_items=None):
        """
        多路召回候选商品
        
        Args:
            user_id: 用户ID
            exclude_items: 需要排除的商品（已购买）
            
        Returns:
            候选商品集合
        """
        exclude_items = set(exclude_items or [])
        candidates = {}
        
        # 1️⃣ 协同过滤召回
        cf_items = self._cf_recall(user_id, exclude_items)
        for item_id, score in cf_items:
            candidates[item_id] = candidates.get(item_id, 0) + score * 0.4
        
        # 2️⃣ 热门商品召回
        for item_id in self.hot_items[:30]:
            if item_id not in exclude_items:
                candidates[item_id] = candidates.get(item_id, 0) + 0.3
        
        # 3️⃣ 基于内容的召回
        content_items = self._content_based_recall(user_id, exclude_items)
        for item_id, score in content_items:
            candidates[item_id] = candidates.get(item_id, 0) + score * 0.3
        
        # 排序并返回top candidates
        sorted_candidates = sorted(
            candidates.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        return sorted_candidates[:self.config['recall_size']]
    
    def _cf_recall(self, user_id, exclude_items):
        """协同过滤召回"""
        if user_id not in self.user_item_matrix.index:
            return []
        
        # 获取用户已评分商品
        user_ratings = self.user_item_matrix.loc[user_id]
        rated_items = user_ratings[user_ratings > 0]
        
        # 基于物品相似度推荐
        scores = {}
        for item_id, rating in rated_items.items():
            similar_items = self.item_similarity[item_id].nlargest(self.config['cf_k'])
            
            for sim_item, similarity in similar_items.items():
                if sim_item not in exclude_items and sim_item not in rated_items.index:
                    scores[sim_item] = scores.get(sim_item, 0) + similarity * rating
        
        # 归一化分数
        if scores:
            max_score = max(scores.values())
            scores = {k: v/max_score for k, v in scores.items()}
        
        return sorted(scores.items(), key=lambda x: x[1], reverse=True)[:30]
    
    def _content_based_recall(self, user_id, exclude_items):
        """基于内容的召回"""
        if user_id not in self.user_profiles:
            return []
        
        profile = self.user_profiles[user_id]
        scores = {}
        
        for item_id, features in self.item_features.items():
            if item_id in exclude_items:
                continue
            
            score = 0
            
            # 类目匹配
            if features['category'] in profile['favorite_categories']:
                score += 0.5
            
            # 品牌匹配  
            if features['brand'] in profile['favorite_brands']:
                score += 0.3
            
            # 价格匹配（价格接近用户偏好）
            if profile['avg_price'] > 0:
                price_diff = abs(features['price'] - profile['avg_price']) / profile['avg_price']
                score += max(0, 0.2 * (1 - price_diff))
            
            if score > 0:
                scores[item_id] = score
        
        return sorted(scores.items(), key=lambda x: x[1], reverse=True)[:30]
    
    # ========== 排序阶段 ==========
    
    def rank_items(self, user_id, candidates):
        """
        精排候选商品
        
        Args:
            user_id: 用户ID
            candidates: 候选商品列表 [(item_id, recall_score), ...]
            
        Returns:
            排序后的推荐列表
        """
        ranked_items = []
        
        for item_id, recall_score in candidates:
            # 综合打分
            final_score = self._calculate_ranking_score(
                user_id, 
                item_id, 
                recall_score
            )
            
            ranked_items.append({
                'item_id': item_id,
                'score': final_score,
                'recall_score': recall_score
            })
        
        # 排序
        ranked_items.sort(key=lambda x: x['score'], reverse=True)
        
        return ranked_items[:self.config['rank_size']]
    
    def _calculate_ranking_score(self, user_id, item_id, recall_score):
        """计算精排分数"""
        score = recall_score
        
        # 商品质量分
        if item_id in self.item_features:
            features = self.item_features[item_id]
            score += features.get('rating', 0) * 0.1
        
        # 新颖性：降低热门商品的分数
        if item_id in self.hot_items:
            popularity_penalty = self.hot_items.index(item_id) / len(self.hot_items)
            score *= (1 - 0.2 * (1 - popularity_penalty))
        
        return score
    
    # ========== 重排与多样性 ==========
    
    def rerank_for_diversity(self, ranked_items):
        """
        重排以提升多样性
        
        使用MMR（Maximal Marginal Relevance）算法
        """
        if not ranked_items:
            return []
        
        final_list = []
        remaining = ranked_items.copy()
        
        # 选择分数最高的作为第一个
        final_list.append(remaining.pop(0))
        
        while remaining and len(final_list) < self.config['rank_size']:
            max_score = -1
            max_idx = 0
            
            for idx, item in enumerate(remaining):
                # 相关性分数
                relevance = item['score']
                
                # 多样性分数（与已选商品的差异）
                diversity = self._calculate_diversity(item, final_list)
                
                # MMR分数
                mmr_score = (
                    (1 - self.config['diversity_weight']) * relevance +
                    self.config['diversity_weight'] * diversity
                )
                
                if mmr_score > max_score:
                    max_score = mmr_score
                    max_idx = idx
            
            final_list.append(remaining.pop(max_idx))
        
        return final_list
    
    def _calculate_diversity(self, item, selected_items):
        """计算商品与已选商品的多样性"""
        if not selected_items:
            return 1.0
        
        item_id = item['item_id']
        if item_id not in self.item_features:
            return 0.5
        
        item_feature = self.item_features[item_id]
        
        # 计算类目多样性
        selected_categories = set()
        for selected in selected_items:
            sel_id = selected['item_id']
            if sel_id in self.item_features:
                selected_categories.add(self.item_features[sel_id]['category'])
        
        # 如果类目不同，多样性高
        if item_feature['category'] not in selected_categories:
            return 1.0
        else:
            return 0.3
    
    # ========== 主推荐接口 ==========
    
    def recommend(self, user_id, exclude_items=None, n_items=10):
        """
        为用户生成推荐列表
        
        Args:
            user_id: 用户ID
            exclude_items: 排除的商品
            n_items: 推荐数量
            
        Returns:
            推荐商品列表
        """
        # 1. 召回
        candidates = self.recall_candidates(user_id, exclude_items)
        
        if not candidates:
            # 冷启动：返回热门商品
            return self._cold_start_recommend(n_items)
        
        # 2. 排序
        ranked = self.rank_items(user_id, candidates)
        
        # 3. 重排（多样性）
        final_recommendations = self.rerank_for_diversity(ranked)
        
        # 4. 返回结果
        return final_recommendations[:n_items]
    
    def _cold_start_recommend(self, n_items):
        """冷启动推荐"""
        return [
            {
                'item_id': item_id,
                'score': 1.0 - idx * 0.05,
                'reason': '热门推荐'
            }
            for idx, item_id in enumerate(self.hot_items[:n_items])
        ]
    
    # ========== 模型持久化 ==========
    
    def save(self, filepath):
        """保存模型"""
        model_data = {
            'config': self.config,
            'user_item_matrix': self.user_item_matrix,
            'item_similarity': self.item_similarity,
            'user_profiles': self.user_profiles,
            'item_features': self.item_features,
            'hot_items': self.hot_items
        }
        joblib.dump(model_data, filepath)
        print(f"✅ 模型已保存到: {filepath}")
    
    @classmethod
    def load(cls, filepath):
        """加载模型"""
        model_data = joblib.load(filepath)
        
        recommender = cls(config=model_data['config'])
        recommender.user_item_matrix = model_data['user_item_matrix']
        recommender.item_similarity = model_data['item_similarity']
        recommender.user_profiles = model_data['user_profiles']
        recommender.item_features = model_data['item_features']
        recommender.hot_items = model_data['hot_items']
        
        print(f"✅ 模型已加载: {filepath}")
        return recommender


# ========== 使用示例 ==========

if __name__ == "__main__":
    # 1. 创建示例数据
    interactions_data = {
        'user_id': [1,1,1,2,2,2,3,3,4,4,5,5,5],
        'item_id': [101,102,103,101,104,105,102,106,101,107,103,105,108],
        'rating': [5,4,3,5,4,5,4,5,5,3,4,5,4],
        'timestamp': pd.date_range('2024-01-01', periods=13)
    }
    interactions_df = pd.DataFrame(interactions_data)
    
    items_data = {
        'item_id': [101,102,103,104,105,106,107,108],
        'category': ['电子','服装','电子','服装','家居','电子','家居','服装'],
        'price': [999,299,1299,199,499,1599,399,249],
        'brand': ['Apple','Nike','Samsung','Adidas','IKEA','Sony','MUJI','Zara'],
        'rating': [4.8,4.5,4.6,4.3,4.7,4.9,4.4,4.2]
    }
    items_df = pd.DataFrame(items_data)
    
    # 2. 训练模型
    print("="*60)
    print("🚀 电商推荐系统训练")
    print("="*60 + "\n")
    
    recommender = EcommerceRecommender(config={
        'cf_k': 5,
        'recall_size': 20,
        'rank_size': 10,
        'diversity_weight': 0.4
    })
    
    recommender.prepare_data(interactions_df, items_df)
    
    # 3. 生成推荐
    print("="*60)
    print("🎯 生成推荐结果")
    print("="*60 + "\n")
    
    user_id = 1
    user_purchased = interactions_df[
        interactions_df['user_id'] == user_id
    ]['item_id'].tolist()
    
    recommendations = recommender.recommend(
        user_id=user_id,
        exclude_items=user_purchased,
        n_items=5
    )
    
    print(f"👤 为用户 {user_id} 推荐商品:")
    print(f"📦 用户已购买: {user_purchased}\n")
    
    for idx, rec in enumerate(recommendations, 1):
        item_id = rec['item_id']
        score = rec['score']
        
        item_info = items_df[items_df['item_id'] == item_id].iloc[0]
        
        print(f"{idx}. 商品ID: {item_id}")
        print(f"   名称: {item_info['brand']} - {item_info['category']}")
        print(f"   价格: ¥{item_info['price']}")
        print(f"   推荐分数: {score:.4f}")
        print()
    
    # 4. 保存模型
    recommender.save('ecommerce_recommender.pkl')
    
    # 5. 加载模型
    loaded_model = EcommerceRecommender.load('ecommerce_recommender.pkl')
    
    print("✅ 推荐系统运行完成！")
```

---

## 16.3 评估指标

### 离线评估

```python
def evaluate_recommender(model, test_df, k=10):
    """评估推荐系统性能"""
    
    precisions = []
    recalls = []
    ndcgs = []
    
    for user_id in test_df['user_id'].unique():
        # 用户实际购买的商品
        actual_items = set(
            test_df[test_df['user_id'] == user_id]['item_id']
        )
        
        # 推荐的商品
        recommendations = model.recommend(user_id, n_items=k)
        recommended_items = set([r['item_id'] for r in recommendations])
        
        # 计算指标
        hits = len(actual_items & recommended_items)
        
        precision = hits / k if k > 0 else 0
        recall = hits / len(actual_items) if len(actual_items) > 0 else 0
        
        precisions.append(precision)
        recalls.append(recall)
    
    return {
        'Precision@K': np.mean(precisions),
        'Recall@K': np.mean(recalls),
        'F1@K': 2 * np.mean(precisions) * np.mean(recalls) / 
                (np.mean(precisions) + np.mean(recalls) + 1e-10)
    }
```

---

## 📚 本章小结

- ✅ 掌握了协同过滤、矩阵分解等经典算法
- ✅ 学习了深度学习推荐模型（NCF）
- ✅ 开发了完整的电商推荐系统
- ✅ 实现了多路召回、精排、重排流程
- ✅ 解决了冷启动和多样性问题

---

## 🎯 练习题

1. **实践题**：优化推荐系统，添加实时特征
2. **扩展题**：实现A/B测试框架评估推荐效果
3. **项目题**：开发内容推荐系统（视频/文章）

---

[⬅️ 上一章](../03-实战篇/15-MLOps工程化.md) | [返回目录](../README.md) | [下一章 ➡️](./17-智能客服系统.md)
