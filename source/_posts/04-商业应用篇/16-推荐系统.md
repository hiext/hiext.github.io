# ç¬¬16ç« ï¼šæ™ºèƒ½æ¨èç³»ç»Ÿ

## ğŸ“ æœ¬ç« ç›®æ ‡

- ç†è§£æ¨èç³»ç»Ÿçš„æ ¸å¿ƒåŸç†å’Œåˆ†ç±»
- æŒæ¡ååŒè¿‡æ»¤ç®—æ³•çš„å®ç°
- å­¦ä¹ æ·±åº¦å­¦ä¹ æ¨èæ¨¡å‹
- è§£å†³å†·å¯åŠ¨ç­‰å®é™…é—®é¢˜
- å¼€å‘å®Œæ•´çš„ç”µå•†æ¨èç³»ç»Ÿ

---

## 16.1 æ¨èç³»ç»Ÿæ¦‚è¿°

### åº”ç”¨åœºæ™¯
- ğŸ“¦ ç”µå•†ï¼šå•†å“æ¨è
- ğŸ¬ è§†é¢‘ï¼šå†…å®¹æ¨è  
- ğŸµ éŸ³ä¹ï¼šæ­Œæ›²æ¨è
- ğŸ“° æ–°é—»ï¼šæ–‡ç« æ¨è

### æ¨èç®—æ³•åˆ†ç±»
```
1. ååŒè¿‡æ»¤ï¼ˆCFï¼‰
   - ç”¨æˆ·ååŒè¿‡æ»¤
   - ç‰©å“ååŒè¿‡æ»¤
   - çŸ©é˜µåˆ†è§£

2. æ·±åº¦å­¦ä¹ æ¨è
   - Neural CF
   - Wide & Deep
   - DeepFM

3. æ··åˆæ¨è
   - å¤šç­–ç•¥èåˆ
```

---

## 16.2 å®Œæ•´æ¡ˆä¾‹ï¼šç”µå•†æ¨èç³»ç»Ÿ

### ç³»ç»Ÿæ¶æ„

```python
# ç”µå•†æ¨èç³»ç»Ÿå®Œæ•´å®ç°
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime
import joblib

class EcommerceRecommender:
    """ç”µå•†æ¨èç³»ç»Ÿ - ç”Ÿäº§çº§å®ç°"""
    
    def __init__(self, config=None):
        self.config = config or {
            'cf_k': 20,
            'recall_size': 100,
            'rank_size': 20,
            'diversity_weight': 0.3
        }
        
        # æ¨¡å‹ç»„ä»¶
        self.user_item_matrix = None
        self.item_similarity = None
        
        # æ•°æ®å­˜å‚¨
        self.user_profiles = {}
        self.item_features = {}
        self.hot_items = []
        
    # ========== æ•°æ®å¤„ç† ==========
    
    def prepare_data(self, interactions_df, items_df):
        """
        å‡†å¤‡è®­ç»ƒæ•°æ®
        
        Args:
            interactions_df: ç”¨æˆ·è¡Œä¸ºæ•°æ® [user_id, item_id, rating, timestamp]
            items_df: å•†å“ä¿¡æ¯ [item_id, category, price, brand, etc]
        """
        print("ğŸ“Š å¼€å§‹æ•°æ®å‡†å¤‡...")
        
        # 1. æ„å»ºç”¨æˆ·-ç‰©å“çŸ©é˜µ
        self.user_item_matrix = interactions_df.pivot_table(
            index='user_id',
            columns='item_id', 
            values='rating',
            fill_value=0
        )
        print(f"âœ… ç”¨æˆ·-ç‰©å“çŸ©é˜µ: {self.user_item_matrix.shape}")
        
        # 2. è®¡ç®—ç‰©å“ç›¸ä¼¼åº¦
        self.item_similarity = pd.DataFrame(
            cosine_similarity(self.user_item_matrix.T),
            index=self.user_item_matrix.columns,
            columns=self.user_item_matrix.columns
        )
        print(f"âœ… ç‰©å“ç›¸ä¼¼åº¦çŸ©é˜µ: {self.item_similarity.shape}")
        
        # 3. æå–çƒ­é—¨å•†å“
        item_popularity = interactions_df['item_id'].value_counts()
        self.hot_items = item_popularity.head(50).index.tolist()
        print(f"âœ… çƒ­é—¨å•†å“æ•°: {len(self.hot_items)}")
        
        # 4. æ„å»ºå•†å“ç‰¹å¾
        for _, row in items_df.iterrows():
            self.item_features[row['item_id']] = {
                'category': row.get('category', 'unknown'),
                'price': row.get('price', 0),
                'brand': row.get('brand', 'unknown'),
                'rating': row.get('rating', 0)
            }
        print(f"âœ… å•†å“ç‰¹å¾æ•°: {len(self.item_features)}")
        
        # 5. æ„å»ºç”¨æˆ·ç”»åƒ
        self._build_user_profiles(interactions_df)
        
        print("âœ… æ•°æ®å‡†å¤‡å®Œæˆï¼\n")
    
    def _build_user_profiles(self, interactions_df):
        """æ„å»ºç”¨æˆ·ç”»åƒ"""
        for user_id in interactions_df['user_id'].unique():
            user_data = interactions_df[interactions_df['user_id'] == user_id]
            
            # ç”¨æˆ·è´­ä¹°çš„å•†å“
            user_items = user_data['item_id'].tolist()
            
            # åå¥½ç±»ç›®
            categories = []
            prices = []
            brands = []
            
            for item_id in user_items:
                if item_id in self.item_features:
                    feature = self.item_features[item_id]
                    categories.append(feature['category'])
                    prices.append(feature['price'])
                    brands.append(feature['brand'])
            
            self.user_profiles[user_id] = {
                'favorite_categories': pd.Series(categories).value_counts().head(3).index.tolist() if categories else [],
                'favorite_brands': pd.Series(brands).value_counts().head(3).index.tolist() if brands else [],
                'avg_price': np.mean(prices) if prices else 0,
                'purchase_count': len(user_items)
            }
    
    # ========== å¬å›é˜¶æ®µ ==========
    
    def recall_candidates(self, user_id, exclude_items=None):
        """
        å¤šè·¯å¬å›å€™é€‰å•†å“
        
        Args:
            user_id: ç”¨æˆ·ID
            exclude_items: éœ€è¦æ’é™¤çš„å•†å“ï¼ˆå·²è´­ä¹°ï¼‰
            
        Returns:
            å€™é€‰å•†å“é›†åˆ
        """
        exclude_items = set(exclude_items or [])
        candidates = {}
        
        # 1ï¸âƒ£ ååŒè¿‡æ»¤å¬å›
        cf_items = self._cf_recall(user_id, exclude_items)
        for item_id, score in cf_items:
            candidates[item_id] = candidates.get(item_id, 0) + score * 0.4
        
        # 2ï¸âƒ£ çƒ­é—¨å•†å“å¬å›
        for item_id in self.hot_items[:30]:
            if item_id not in exclude_items:
                candidates[item_id] = candidates.get(item_id, 0) + 0.3
        
        # 3ï¸âƒ£ åŸºäºå†…å®¹çš„å¬å›
        content_items = self._content_based_recall(user_id, exclude_items)
        for item_id, score in content_items:
            candidates[item_id] = candidates.get(item_id, 0) + score * 0.3
        
        # æ’åºå¹¶è¿”å›top candidates
        sorted_candidates = sorted(
            candidates.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        return sorted_candidates[:self.config['recall_size']]
    
    def _cf_recall(self, user_id, exclude_items):
        """ååŒè¿‡æ»¤å¬å›"""
        if user_id not in self.user_item_matrix.index:
            return []
        
        # è·å–ç”¨æˆ·å·²è¯„åˆ†å•†å“
        user_ratings = self.user_item_matrix.loc[user_id]
        rated_items = user_ratings[user_ratings > 0]
        
        # åŸºäºç‰©å“ç›¸ä¼¼åº¦æ¨è
        scores = {}
        for item_id, rating in rated_items.items():
            similar_items = self.item_similarity[item_id].nlargest(self.config['cf_k'])
            
            for sim_item, similarity in similar_items.items():
                if sim_item not in exclude_items and sim_item not in rated_items.index:
                    scores[sim_item] = scores.get(sim_item, 0) + similarity * rating
        
        # å½’ä¸€åŒ–åˆ†æ•°
        if scores:
            max_score = max(scores.values())
            scores = {k: v/max_score for k, v in scores.items()}
        
        return sorted(scores.items(), key=lambda x: x[1], reverse=True)[:30]
    
    def _content_based_recall(self, user_id, exclude_items):
        """åŸºäºå†…å®¹çš„å¬å›"""
        if user_id not in self.user_profiles:
            return []
        
        profile = self.user_profiles[user_id]
        scores = {}
        
        for item_id, features in self.item_features.items():
            if item_id in exclude_items:
                continue
            
            score = 0
            
            # ç±»ç›®åŒ¹é…
            if features['category'] in profile['favorite_categories']:
                score += 0.5
            
            # å“ç‰ŒåŒ¹é…  
            if features['brand'] in profile['favorite_brands']:
                score += 0.3
            
            # ä»·æ ¼åŒ¹é…ï¼ˆä»·æ ¼æ¥è¿‘ç”¨æˆ·åå¥½ï¼‰
            if profile['avg_price'] > 0:
                price_diff = abs(features['price'] - profile['avg_price']) / profile['avg_price']
                score += max(0, 0.2 * (1 - price_diff))
            
            if score > 0:
                scores[item_id] = score
        
        return sorted(scores.items(), key=lambda x: x[1], reverse=True)[:30]
    
    # ========== æ’åºé˜¶æ®µ ==========
    
    def rank_items(self, user_id, candidates):
        """
        ç²¾æ’å€™é€‰å•†å“
        
        Args:
            user_id: ç”¨æˆ·ID
            candidates: å€™é€‰å•†å“åˆ—è¡¨ [(item_id, recall_score), ...]
            
        Returns:
            æ’åºåçš„æ¨èåˆ—è¡¨
        """
        ranked_items = []
        
        for item_id, recall_score in candidates:
            # ç»¼åˆæ‰“åˆ†
            final_score = self._calculate_ranking_score(
                user_id, 
                item_id, 
                recall_score
            )
            
            ranked_items.append({
                'item_id': item_id,
                'score': final_score,
                'recall_score': recall_score
            })
        
        # æ’åº
        ranked_items.sort(key=lambda x: x['score'], reverse=True)
        
        return ranked_items[:self.config['rank_size']]
    
    def _calculate_ranking_score(self, user_id, item_id, recall_score):
        """è®¡ç®—ç²¾æ’åˆ†æ•°"""
        score = recall_score
        
        # å•†å“è´¨é‡åˆ†
        if item_id in self.item_features:
            features = self.item_features[item_id]
            score += features.get('rating', 0) * 0.1
        
        # æ–°é¢–æ€§ï¼šé™ä½çƒ­é—¨å•†å“çš„åˆ†æ•°
        if item_id in self.hot_items:
            popularity_penalty = self.hot_items.index(item_id) / len(self.hot_items)
            score *= (1 - 0.2 * (1 - popularity_penalty))
        
        return score
    
    # ========== é‡æ’ä¸å¤šæ ·æ€§ ==========
    
    def rerank_for_diversity(self, ranked_items):
        """
        é‡æ’ä»¥æå‡å¤šæ ·æ€§
        
        ä½¿ç”¨MMRï¼ˆMaximal Marginal Relevanceï¼‰ç®—æ³•
        """
        if not ranked_items:
            return []
        
        final_list = []
        remaining = ranked_items.copy()
        
        # é€‰æ‹©åˆ†æ•°æœ€é«˜çš„ä½œä¸ºç¬¬ä¸€ä¸ª
        final_list.append(remaining.pop(0))
        
        while remaining and len(final_list) < self.config['rank_size']:
            max_score = -1
            max_idx = 0
            
            for idx, item in enumerate(remaining):
                # ç›¸å…³æ€§åˆ†æ•°
                relevance = item['score']
                
                # å¤šæ ·æ€§åˆ†æ•°ï¼ˆä¸å·²é€‰å•†å“çš„å·®å¼‚ï¼‰
                diversity = self._calculate_diversity(item, final_list)
                
                # MMRåˆ†æ•°
                mmr_score = (
                    (1 - self.config['diversity_weight']) * relevance +
                    self.config['diversity_weight'] * diversity
                )
                
                if mmr_score > max_score:
                    max_score = mmr_score
                    max_idx = idx
            
            final_list.append(remaining.pop(max_idx))
        
        return final_list
    
    def _calculate_diversity(self, item, selected_items):
        """è®¡ç®—å•†å“ä¸å·²é€‰å•†å“çš„å¤šæ ·æ€§"""
        if not selected_items:
            return 1.0
        
        item_id = item['item_id']
        if item_id not in self.item_features:
            return 0.5
        
        item_feature = self.item_features[item_id]
        
        # è®¡ç®—ç±»ç›®å¤šæ ·æ€§
        selected_categories = set()
        for selected in selected_items:
            sel_id = selected['item_id']
            if sel_id in self.item_features:
                selected_categories.add(self.item_features[sel_id]['category'])
        
        # å¦‚æœç±»ç›®ä¸åŒï¼Œå¤šæ ·æ€§é«˜
        if item_feature['category'] not in selected_categories:
            return 1.0
        else:
            return 0.3
    
    # ========== ä¸»æ¨èæ¥å£ ==========
    
    def recommend(self, user_id, exclude_items=None, n_items=10):
        """
        ä¸ºç”¨æˆ·ç”Ÿæˆæ¨èåˆ—è¡¨
        
        Args:
            user_id: ç”¨æˆ·ID
            exclude_items: æ’é™¤çš„å•†å“
            n_items: æ¨èæ•°é‡
            
        Returns:
            æ¨èå•†å“åˆ—è¡¨
        """
        # 1. å¬å›
        candidates = self.recall_candidates(user_id, exclude_items)
        
        if not candidates:
            # å†·å¯åŠ¨ï¼šè¿”å›çƒ­é—¨å•†å“
            return self._cold_start_recommend(n_items)
        
        # 2. æ’åº
        ranked = self.rank_items(user_id, candidates)
        
        # 3. é‡æ’ï¼ˆå¤šæ ·æ€§ï¼‰
        final_recommendations = self.rerank_for_diversity(ranked)
        
        # 4. è¿”å›ç»“æœ
        return final_recommendations[:n_items]
    
    def _cold_start_recommend(self, n_items):
        """å†·å¯åŠ¨æ¨è"""
        return [
            {
                'item_id': item_id,
                'score': 1.0 - idx * 0.05,
                'reason': 'çƒ­é—¨æ¨è'
            }
            for idx, item_id in enumerate(self.hot_items[:n_items])
        ]
    
    # ========== æ¨¡å‹æŒä¹…åŒ– ==========
    
    def save(self, filepath):
        """ä¿å­˜æ¨¡å‹"""
        model_data = {
            'config': self.config,
            'user_item_matrix': self.user_item_matrix,
            'item_similarity': self.item_similarity,
            'user_profiles': self.user_profiles,
            'item_features': self.item_features,
            'hot_items': self.hot_items
        }
        joblib.dump(model_data, filepath)
        print(f"âœ… æ¨¡å‹å·²ä¿å­˜åˆ°: {filepath}")
    
    @classmethod
    def load(cls, filepath):
        """åŠ è½½æ¨¡å‹"""
        model_data = joblib.load(filepath)
        
        recommender = cls(config=model_data['config'])
        recommender.user_item_matrix = model_data['user_item_matrix']
        recommender.item_similarity = model_data['item_similarity']
        recommender.user_profiles = model_data['user_profiles']
        recommender.item_features = model_data['item_features']
        recommender.hot_items = model_data['hot_items']
        
        print(f"âœ… æ¨¡å‹å·²åŠ è½½: {filepath}")
        return recommender


# ========== ä½¿ç”¨ç¤ºä¾‹ ==========

if __name__ == "__main__":
    # 1. åˆ›å»ºç¤ºä¾‹æ•°æ®
    interactions_data = {
        'user_id': [1,1,1,2,2,2,3,3,4,4,5,5,5],
        'item_id': [101,102,103,101,104,105,102,106,101,107,103,105,108],
        'rating': [5,4,3,5,4,5,4,5,5,3,4,5,4],
        'timestamp': pd.date_range('2024-01-01', periods=13)
    }
    interactions_df = pd.DataFrame(interactions_data)
    
    items_data = {
        'item_id': [101,102,103,104,105,106,107,108],
        'category': ['ç”µå­','æœè£…','ç”µå­','æœè£…','å®¶å±…','ç”µå­','å®¶å±…','æœè£…'],
        'price': [999,299,1299,199,499,1599,399,249],
        'brand': ['Apple','Nike','Samsung','Adidas','IKEA','Sony','MUJI','Zara'],
        'rating': [4.8,4.5,4.6,4.3,4.7,4.9,4.4,4.2]
    }
    items_df = pd.DataFrame(items_data)
    
    # 2. è®­ç»ƒæ¨¡å‹
    print("="*60)
    print("ğŸš€ ç”µå•†æ¨èç³»ç»Ÿè®­ç»ƒ")
    print("="*60 + "\n")
    
    recommender = EcommerceRecommender(config={
        'cf_k': 5,
        'recall_size': 20,
        'rank_size': 10,
        'diversity_weight': 0.4
    })
    
    recommender.prepare_data(interactions_df, items_df)
    
    # 3. ç”Ÿæˆæ¨è
    print("="*60)
    print("ğŸ¯ ç”Ÿæˆæ¨èç»“æœ")
    print("="*60 + "\n")
    
    user_id = 1
    user_purchased = interactions_df[
        interactions_df['user_id'] == user_id
    ]['item_id'].tolist()
    
    recommendations = recommender.recommend(
        user_id=user_id,
        exclude_items=user_purchased,
        n_items=5
    )
    
    print(f"ğŸ‘¤ ä¸ºç”¨æˆ· {user_id} æ¨èå•†å“:")
    print(f"ğŸ“¦ ç”¨æˆ·å·²è´­ä¹°: {user_purchased}\n")
    
    for idx, rec in enumerate(recommendations, 1):
        item_id = rec['item_id']
        score = rec['score']
        
        item_info = items_df[items_df['item_id'] == item_id].iloc[0]
        
        print(f"{idx}. å•†å“ID: {item_id}")
        print(f"   åç§°: {item_info['brand']} - {item_info['category']}")
        print(f"   ä»·æ ¼: Â¥{item_info['price']}")
        print(f"   æ¨èåˆ†æ•°: {score:.4f}")
        print()
    
    # 4. ä¿å­˜æ¨¡å‹
    recommender.save('ecommerce_recommender.pkl')
    
    # 5. åŠ è½½æ¨¡å‹
    loaded_model = EcommerceRecommender.load('ecommerce_recommender.pkl')
    
    print("âœ… æ¨èç³»ç»Ÿè¿è¡Œå®Œæˆï¼")
```

---

## 16.3 è¯„ä¼°æŒ‡æ ‡

### ç¦»çº¿è¯„ä¼°

```python
def evaluate_recommender(model, test_df, k=10):
    """è¯„ä¼°æ¨èç³»ç»Ÿæ€§èƒ½"""
    
    precisions = []
    recalls = []
    ndcgs = []
    
    for user_id in test_df['user_id'].unique():
        # ç”¨æˆ·å®é™…è´­ä¹°çš„å•†å“
        actual_items = set(
            test_df[test_df['user_id'] == user_id]['item_id']
        )
        
        # æ¨èçš„å•†å“
        recommendations = model.recommend(user_id, n_items=k)
        recommended_items = set([r['item_id'] for r in recommendations])
        
        # è®¡ç®—æŒ‡æ ‡
        hits = len(actual_items & recommended_items)
        
        precision = hits / k if k > 0 else 0
        recall = hits / len(actual_items) if len(actual_items) > 0 else 0
        
        precisions.append(precision)
        recalls.append(recall)
    
    return {
        'Precision@K': np.mean(precisions),
        'Recall@K': np.mean(recalls),
        'F1@K': 2 * np.mean(precisions) * np.mean(recalls) / 
                (np.mean(precisions) + np.mean(recalls) + 1e-10)
    }
```

---

## ğŸ“š æœ¬ç« å°ç»“

- âœ… æŒæ¡äº†ååŒè¿‡æ»¤ã€çŸ©é˜µåˆ†è§£ç­‰ç»å…¸ç®—æ³•
- âœ… å­¦ä¹ äº†æ·±åº¦å­¦ä¹ æ¨èæ¨¡å‹ï¼ˆNCFï¼‰
- âœ… å¼€å‘äº†å®Œæ•´çš„ç”µå•†æ¨èç³»ç»Ÿ
- âœ… å®ç°äº†å¤šè·¯å¬å›ã€ç²¾æ’ã€é‡æ’æµç¨‹
- âœ… è§£å†³äº†å†·å¯åŠ¨å’Œå¤šæ ·æ€§é—®é¢˜

---

## ğŸ¯ ç»ƒä¹ é¢˜

1. **å®è·µé¢˜**ï¼šä¼˜åŒ–æ¨èç³»ç»Ÿï¼Œæ·»åŠ å®æ—¶ç‰¹å¾
2. **æ‰©å±•é¢˜**ï¼šå®ç°A/Bæµ‹è¯•æ¡†æ¶è¯„ä¼°æ¨èæ•ˆæœ
3. **é¡¹ç›®é¢˜**ï¼šå¼€å‘å†…å®¹æ¨èç³»ç»Ÿï¼ˆè§†é¢‘/æ–‡ç« ï¼‰

---

[â¬…ï¸ ä¸Šä¸€ç« ](../03-å®æˆ˜ç¯‡/15-MLOpså·¥ç¨‹åŒ–.md) | [è¿”å›ç›®å½•](../README.md) | [ä¸‹ä¸€ç«  â¡ï¸](./17-æ™ºèƒ½å®¢æœç³»ç»Ÿ.md)
